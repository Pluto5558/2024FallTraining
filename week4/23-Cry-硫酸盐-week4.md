<h1 id="s7Jrj">E1</h1>
题目如下

```plain
from Crypto.Util.number import getPrime
from libnum import s2n
from secret import flag

p = getPrime(256)
a = getPrime(256)
b = getPrime(256)
E = EllipticCurve(GF(p), [a, b])
m = E.random_point()
G = E.random_point()
k = getPrime(256)
K = k * G
r = getPrime(256)
c1 = m + r * K
c2 = r * G
cipher_left = s2n(flag[:len(flag)//2]) * m[0]
cipher_right = s2n(flag[len(flag)//2:]) * m[1]

print(f"p = {p}")
print(f"a = {a}")
print(f"b = {b}")
print(f"k = {k}")
print(f"E = {E}")
print(f"c1 = {c1}")
print(f"c2 = {c2}")
print(f"cipher_left = {cipher_left}")
print(f"cipher_right = {cipher_right}")
'''
p = 74997021559434065975272431626618720725838473091721936616560359000648651891507
a = 61739043730332859978236469007948666997510544212362386629062032094925353519657
b = 87821782818477817609882526316479721490919815013668096771992360002467657827319
k = 93653874272176107584459982058527081604083871182797816204772644509623271061231
E = Elliptic Curve defined by y^2 = x^3 + 61739043730332859978236469007948666997510544212362386629062032094925353519657*x + 12824761259043751634610094689861000765081341921946160155432001001819005935812 over Finite Field of size 74997021559434065975272431626618720725838473091721936616560359000648651891507
c1 = (14455613666211899576018835165132438102011988264607146511938249744871964946084 : 25506582570581289714612640493258299813803157561796247330693768146763035791942 : 1)
c2 = (37554871162619456709183509122673929636457622251880199235054734523782483869931 : 71392055540616736539267960989304287083629288530398474590782366384873814477806 : 1)
cipher_left = 68208062402162616009217039034331142786282678107650228761709584478779998734710
cipher_right = 27453988545002384546706933590432585006240439443312571008791835203660152890619

'''
```



因为

K = k * G，c1 = m + r * K，c2 = r * G

所以

m = c1 - k*c2

然后直接解题就行



解题脚本如下

```plain
"""
p = 74997021559434065975272431626618720725838473091721936616560359000648651891507
a = 61739043730332859978236469007948666997510544212362386629062032094925353519657
b = 87821782818477817609882526316479721490919815013668096771992360002467657827319
k = 93653874272176107584459982058527081604083871182797816204772644509623271061231
E = EllipticCurve(GF(p), [a, b])
c1 = E([14455613666211899576018835165132438102011988264607146511938249744871964946084,25506582570581289714612640493258299813803157561796247330693768146763035791942])
c2 = E([37554871162619456709183509122673929636457622251880199235054734523782483869931,71392055540616736539267960989304287083629288530398474590782366384873814477806])
m = c1 - c2 * k
cipher_left = 68208062402162616009217039034331142786282678107650228761709584478779998734710
cipher_right = 27453988545002384546706933590432585006240439443312571008791835203660152890619
flag_left = cipher_left//m[0]
flag_right = cipher_right//m[1]
"""
from libnum import n2s

flag_left = 493033149237009446036260
flag_right =127480900256551022095393917

print(n2s(flag_left)+n2s(flag_right))
# b'hgame{Ecc$is!sO@HaRd}'
```

---

<h1 id="RBz0c">E2</h1>
题目如下

```plain
# coding: utf-8
#!/usr/bin/env python2

import gmpy2
import random
import binascii
from hashlib import sha256
from sympy import nextprime
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Util.number import long_to_bytes
from FLAG import flag
#flag = 'wdflag{123}'


def victory_encrypt(plaintext, key):
    key = key.upper()
    key_length = len(key)
    plaintext = plaintext.upper()
    ciphertext = ''

    for i, char in enumerate(plaintext):
        if char.isalpha():
            shift = ord(key[i % key_length]) - ord('A')
            encrypted_char = chr(
                (ord(char) - ord('A') + shift) % 26 + ord('A'))
            ciphertext += encrypted_char
        else:
            ciphertext += char

    return ciphertext


victory_key = "WANGDINGCUP"
victory_encrypted_flag = victory_encrypt(flag, victory_key)

# 椭圆曲线参数
p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
a = 0
b = 7
xG = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
yG = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
G = (xG, yG)
n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
h = 1
zero = (0, 0)

# 私钥生成
dA = nextprime(random.randint(0, n))

if dA > n:
    print("warning!!")

# 点的加法
def addition(t1, t2):
    if t1 == zero:
        return t2
    if t2 == zero:
        return t2
    (m1, n1) = t1
    (m2, n2) = t2
    if m1 == m2:
        if n1 == 0 or n1 != n2:
            return zero
        else:
            k = (3 * m1 * m1 + a) % p * gmpy2.invert(2 * n1, p) % p
    else:
        k = (n2 - n1 + p) % p * gmpy2.invert((m2 - m1 + p) % p, p) % p
    m3 = (k * k % p - m1 - m2 + p * 2) % p
    n3 = (k * (m1 - m3) % p - n1 + p) % p
    return (int(m3), int(n3))

# 点的乘法
def multiplication(x, k):
    ans = zero
    t = 1
    while(t <= k):
        if (k & t) > 0:
            ans = addition(ans, x)
        x = addition(x, x)
        t <<= 1
    return ans

#数字签名
def getrs(z, k):
    (xp, yp) = P
    r = xp
    s = (z + r * dA % n) % n * gmpy2.invert(k, n) % n
    return r, s

#随机数生成和签名计算
z1 = random.randint(0, p)
z2 = random.randint(0, p)
k = random.randint(0, n)
P = multiplication(G, k)
hA = multiplication(G, dA)
r1, s1 = getrs(z1, k)
r2, s2 = getrs(z2, k)

print("r1 = {}".format(r1))
print("r2 = {}".format(r2))
print("s1 = {}".format(s1))
print("s2 = {}".format(s2))
print("z1 = {}".format(z1))
print("z2 = {}".format(z2))

key = sha256(long_to_bytes(dA)).digest()
cipher = AES.new(key, AES.MODE_CBC)
iv = cipher.iv
encrypted_flag = cipher.encrypt(
    pad(victory_encrypted_flag.encode(), AES.block_size))
encrypted_flag_hex = binascii.hexlify(iv + encrypted_flag).decode('utf-8')

print("Encrypted flag (AES in CBC mode, hex):", encrypted_flag_hex)

# output
# r1 = 111817653331957669294460466848850458804857945556928458406600106150268654577388
# r2 = 111817653331957669294460466848850458804857945556928458406600106150268654577388
# s1 = 86614391420642776223990568523561232627667766343605236785504627521619587526774
# s2 = 99777373725561160499828739472284705447694429465579067222876023876942075279416
# z1 = 96525870193778873849147733081234547336150390817999790407096946391065286856874
# z2 = 80138688082399628724400273131729065525373481983222188646486307533062536927379
# ('Encrypted flag (AES in CBC mode, hex):', u'6c201c3c4e8b0a2cdd0eca11e7101d45d7b33147d27ad1b9d57e3d1e20c7b3c2e36b8da3142dfd5abe335a604ce7018878b9f157099211a7bbda56ef5285ec0b')
```



这道题先是用<font style="color:rgb(6, 6, 7);">密钥 victory_key 用于对明文 flag 进行加密。</font>然后是椭圆曲线的 ECDSA ，对 z 和 k 进行了数字签名，生成了一个包含 r 和 s 的签名对。<font style="color:rgb(6, 6, 7);">最后，代码使用 SHA-256 哈希函数计算私钥 dA 的哈希值，使用这个哈希值作为 AES 加密的密钥。</font>

<font style="color:rgb(6, 6, 7);"></font>

<font style="color:rgb(28, 31, 35);">给定签名方程：</font>

s = (z + r*dA) * k⁻¹ mod n

可转换成：

k = (z + r*dA) * s⁻¹ mod n

dA = [(s * k) - z] * r⁻¹ mod n

因为 r1 和 r2 得值相等

s1 = (z1 + r1*dA) * k⁻¹ mod n

s2 = (z2 + r2*dA) * k⁻¹ mod n

两式相减，得

s1 - s1 = (z1 - z2) * k⁻¹ mod n

所以

k = (z1 - z2)/(s1 - s2) mod n



算出 k 和 dA 的值后，可以求出 key 的值，用 key 进行AES的CBC模式解密。

最后定义凯撒密码解密函数 victory_decrypt ，只需要把原来加密函数的 "+ shift" 改成 "- shift" 就行



解题脚本如下

```plain
from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.number import *

r1 = 111817653331957669294460466848850458804857945556928458406600106150268654577388
r2 = 111817653331957669294460466848850458804857945556928458406600106150268654577388
s1 = 86614391420642776223990568523561232627667766343605236785504627521619587526774
s2 = 99777373725561160499828739472284705447694429465579067222876023876942075279416
z1 = 96525870193778873849147733081234547336150390817999790407096946391065286856874
z2 = 80138688082399628724400273131729065525373481983222188646486307533062536927379
Encrypted_flag_hex = '6c201c3c4e8b0a2cdd0eca11e7101d45d7b33147d27ad1b9d57e3d1e20c7b3c2e36b8da3142dfd5abe335a604ce7018878b9f157099211a7bbda56ef5285ec0b'
victory_key = "WANGDINGCUP"
n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

# 解密，只需要把原来的victory_encrypt中的 + shift 改成 - shift
def victory_decrypt(plaintext, key):
    key = key.upper()
    key_length = len(key)
    plaintext = plaintext.upper()
    ciphertext = ''

    for i, char in enumerate(plaintext):
        if char.isalpha():
            shift = ord(key[i % key_length]) - ord('A')
            encrypted_char = chr((ord(char) - ord('A') - shift) % 26 + ord('A'))
            ciphertext += encrypted_char
        else:
            ciphertext += char

    return ciphertext

# 先求出 k 和 dA，从而求出 key
delta_z = (z1 - z2) % n
delta_s = (s1 - s2) % n
k = (delta_z * inverse(delta_s, n)) % n
dA = (s1 * k - z1) * inverse(r1, n) % n

key = sha256(long_to_bytes(dA)).digest()

Encrypted_flag_bytes = bytes.fromhex(Encrypted_flag_hex)
iv = Encrypted_flag_bytes[:16]
c = Encrypted_flag_bytes[16:]


# AES的CBC模式解密
def decrypt(c, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted = cipher.decrypt(c)
    return decrypted
print(decrypt(c, key, iv))

flag = victory_decrypt('SDSRDO{58UT00432L8228R9E3G927HDWS8D67G2}', victory_key)
print(flag)
# b'SDSRDO{58UT00432L8228R9E3G927HDWS8D67G2}\x08\x08\x08\x08\x08\x08\x08\x08'
# WDFLAG{58AE00432D8228C9E3A927BBCD8D67D2}
```

---

<h1 id="wCS1M">L1</h1>
题目如下

```plain
from Crypto.Util.number import *
from gmpy2 import *

flag = b'******'
flag = bytes_to_long(flag)

p = getPrime(1024)
r = getPrime(175)
a = inverse(r, p)
a = (a*flag) % p

print(f'a = {a}')
print(f'p = {p}')
'''
a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247
p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591
'''
```



因为

a = (a*flag) % p = (inverse(r, p)*flag) % p = r⁻¹ * flag % p

a*r = flag % p 

flag = a*r + k*p

构造格

[k,r][[p,0],[a,1]] = [flag,r]



解题脚本如下

```plain
from Crypto.Util.number import *

"""
sage
a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247
p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591
mat = [[p,0],[a,1]]
M = Matrix(ZZ,mat)
flag,r= M.LLL()[0]
flag,r
"""
flag = 2806865643354785604818499451677377555595926723057578185821996633730638307134392376861144639392481821419133
r = 26590414995611344965535328239224615706885235791693081

print(long_to_bytes(flag))
# b'NSSCTF{e572546b-abb5-4358-8970-471abc12b7ef}'
```

---

<h1 id="d5z34">L2</h1>
题目如下

```plain
from Crypto.Util.number import *
from gmpy2 import *

flag = b'******'
m = bytes_to_long(flag)

assert m.bit_length() == 351
p = getPrime(1024)
b = getPrime(1024)
c = getPrime(400)

a = (b*m + c) % p

print(f'a = {a}')
print(f'b = {b}')
print(f'p = {p}')

'''
a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592
b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663
p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783
'''
```



由题目我们可以知道，m 的比特长度为351位，这是一个后续的验证条件。因为 p，b 的比特长度是1024位，c 的比特长度是400位，所以先构造格

a = (b*m + c) % p

a = b*m + c -k*p

c = k*p - b*m + a

[k,m,1] [[p,0,0],[-b,1,0],[a,0,1]] = [c,m,1]

接下来就是配平，说实话我还没弄明白怎么配平，我是用一种取巧的方式完成的，就是把 2 的 100次方，200次方，300次方，400次方……都代进去，看求出的 m 的结果，这题我就是发现用 2²⁰⁰，2³⁰⁰，2⁴⁰⁰ 求出来的 m 是同一个数，于是我就配了 2²⁰⁰。



解题脚本如下

```plain
from Crypto.Util.number import *
"""
sage
a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592
b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663
p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783
mat = [[p,0,0],[-b,1,0],[a,0,2**200]]
M = Matrix(ZZ,mat)
_,m,_ = M.LLL()[0]
m
"""
m = 2806865643354785604911733839108822171359760330952936507533493276866418947147425514569993579910688788275581
assert m.bit_length() == 351
print(long_to_bytes(m))
# b'NSSCTF{ee5cb1a5-257a-48b0-9d62-9ef56ff0651a}'
```





