<h1 id="FkKwv">1.base64</h1>
![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1731935187115-05dd4955-c398-4c40-bbf4-a9ea9b1e8a23.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1731935279950-12ea56af-8781-488f-8081-774d3a687291.png)

~~拖进ida还是这俩报错，ok打不开下一题~~

经过了一晚上和一个白天努力之后点开exe变成了这个报错~~DirectXrepair我试过了，Redistributable自带的repair我试过了，卸载了重装我也试过了，第三方付费软件我也试过了，ai和csdn给的法子我都试过了，我尽力了~~

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732039718877-00f47d94-f682-4913-9cd9-23108754d6a3.png)

但是谢天谢地拖进ida终于不报错了，总算是可以做题了~~~~

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1731945329535-f229eea0-bd64-4fff-b8ac-6129f0dc29ad.png)

> pdb是调试文件，只有出题者才有，所以这里切记要选No
>

拽进ida然后直接f5就能看到c语言的伪代码了![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1731991857363-249b96af-ff2e-4fd9-adf6-443b24e1e3fa.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732005720234-ca2004f6-da12-4990-b81d-11263ae66c7e.png)

双击打开main就能看到完整汇编语言的形式了

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732038098273-a185ad10-0eef-41e2-a590-e7c2f6e3f893.png)

然后在ida中能看到ABCDE这一串，就是base64编码的经典标志了，正好也和这次的exe名字相呼应

base64编码的过程如下：

> 1. **<font style="color:rgb(26, 32, 41);">将二进制数据分组</font>**<font style="color:rgb(26, 32, 41);">：将需要编码的二进制数据分为每组3个字节，也就是24位。</font>
> 2. **<font style="color:rgb(26, 32, 41);">将24位分为4组，每组6位</font>**<font style="color:rgb(26, 32, 41);">：将这24位划分为4组，每组6位。</font>
> 3. **<font style="color:rgb(26, 32, 41);">每组6位转换为十进制</font>**<font style="color:rgb(26, 32, 41);">：每组6位可以转换成一个0到63之间的十进制数。</font>
> 4. **<font style="color:rgb(26, 32, 41);">查找对应的Base64字符</font>**<font style="color:rgb(26, 32, 41);">：根据上一步得到的十进制数，在Base64索引表中查找对应的字符。Base64索引表包含了64个字符，分别是：</font>
>     - <font style="color:rgb(26, 32, 41);">大写字母A到Z（26个）</font>
>     - <font style="color:rgb(26, 32, 41);">小写字母a到z（26个）</font>
>     - <font style="color:rgb(26, 32, 41);">数字0到9（10个）</font>
>     - <font style="color:rgb(26, 32, 41);">加号（+）和斜杠（/）两个符号</font>
>
> <font style="color:rgb(26, 32, 41);">这样，每6位二进制数就转换成了索引表中的一个字符。</font>
>
> 5. **<font style="color:rgb(26, 32, 41);">填充</font>**<font style="color:rgb(26, 32, 41);">：如果待编码的二进制数据不是3的倍数，最后会剩下1个或2个字节。这时，需要在数据的尾部添加一个或两个填充字符（通常是’='），以使最后的编码数据长度为4的倍数。</font>
>

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732038997892-de004358-5c97-4e6f-ad14-a0dc4e689040.png)

在这里我们也是注意到Destination和Str2进行了一次str compare，因此我们需要着重找到Str2是什么东西

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732039116947-ca7a7b15-abd5-4ecf-aa70-6fb6f83011a5.png)

在right flag和wrong flag的正上方找到了这一坨，显然像是flag经过了某些处理的形式，这个就是下半段代码告诉我们的东西，那么目光重新回到上半段代码

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732039634685-4df42a80-7c9d-4390-8057-361716c2cd6e.png)

不知道是不是因为报错的缘故或者是出题者有意为之，这里的函数名字相当奇怪，不过根据做题经验还是不难猜出来sub_41132F类似于printf，sub_411375类似于scanf，并且会检查输入的前20个字节

但是这个sub_4110BE并不能直接看出来会对Str，v3和v4进行什么操作，所以双击打开它

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732040549012-d14bbcac-aa20-48e6-87ed-be8ba4c97a01.png)

再追这个411AB0~~从这里就基本能看出来是有意为之了，毕竟刚到手的时候main0也没展开，很符合这位师傅的风格~~

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732040731760-792bbe6f-f39f-424d-acd8-ab745df51b9d.png)

虽然看上去让人很头大，还是慢慢分析

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732041212735-86faa41a-26e2-4bf1-aebc-fad54652376f.png)

这里的/3和*4，以及下文的while内接if和switch进行操作就验证了上文对文件名和特殊字段猜测的base64编码方式，再分析一下此处代码段的大致含义，从while段的v11开始看起

v11=a2，而a2是一个形参，追回主函数实际值为v3，也就是我们输入字符串的长度，因此这个while意在对我们输入的字符进行逐字处理，依据后面来看及文件名提示即为base64编码，综上，sub_4110BE即为对输入字符串进行base64编码的函数

随后回到主函数来看，后面还有个for会让我们输入字符的第j个+j

由此处理完之后便能得到一个应该和Str2（<font style="color:rgb(26, 32, 41);">e3nifIH9b_C@n@dH）一样的东西</font>

<font style="color:rgb(26, 32, 41);">因此回到C语言</font>~~<font style="color:rgb(26, 32, 41);">因为我目前并不知道C用哪个头文件可以base64，</font>~~<font style="color:rgb(26, 32, 41);">先把这串东西减去对应位数再丢到网上进行base64解码即可</font>

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732043899844-eec146c7-1193-4842-81c0-12cc3451ffc6.png)

按照上文for加的方式反向减去for加的数值，c语言编程如图所示，编译，link并运行即可得到结果e2lfbDB2ZV95b3V9d

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732044017011-ceb8e4c5-6663-404e-802b-1d1c373a6250.png)

拉到网上的base64解码器即可得到本题的flag   {i_l0ve_you}

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732044080464-1dc49a76-a4ad-4021-9bb6-8887ef03a56b.png)

---

<h1 id="LObys">2.justpyc</h1>
也是按照惯例直接拖进IDA啊

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732112882302-b98f31a1-37db-4ab7-b08c-dda969cfbb2b.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732112897066-d33d05a2-ddd9-4bde-8a37-d25e391e9458.png)

欸。。。不管用了（唯一的收获是知道了input1可能和flag有关系

那么.pyc是什么呢

> <font style="color:rgb(26, 32, 41);">pyc文件是Python语言中的编译字节码文件。当你运行一个.py文件时，Python解释器会将其源代码编译成字节码。这个字节码是一种低级、与平台无关的形式，它可以被Python解释器快速执行，但不可被直接阅读。</font>
>
> **<font style="color:rgb(26, 32, 41);">生成方式</font>**<font style="color:rgb(26, 32, 41);">：Python解释器在首次导入模块时，会读取.py文件，并将其编译成.pyc文件。这些.pyc文件通常位于与源代码相同的目录下的__pycache__文件夹中。</font>
>
> **<font style="color:rgb(26, 32, 41);">作用</font>**<font style="color:rgb(26, 32, 41);">：这些字节码文件可以加快后续模块的加载速度，因为解释器可以直接使用这些编译过的字节码，而不需要再次解析和编译源代码。</font>
>
> **<font style="color:rgb(26, 32, 41);">跨平台性</font>**<font style="color:rgb(26, 32, 41);">：.pyc文件在不同的平台上通常是不可移植的，因为字节码可能依赖于特定的Python解释器版本。</font>
>
> **<font style="color:rgb(26, 32, 41);">隐私性</font>**<font style="color:rgb(26, 32, 41);">：由于.pyc文件不是人类可读的，它可以提供一定程度的源代码保护。但是，需要注意的是，字节码相对容易反编译，因此不能作为安全的代码加密手段。</font>
>
> **<font style="color:rgb(26, 32, 41);">优化</font>**<font style="color:rgb(26, 32, 41);">：在某些情况下，Python解释器可以进一步优化字节码，生成优化的.pyc文件，这通常在解释器使用 </font>`<font style="color:rgb(26, 32, 41);">-O</font>`<font style="color:rgb(26, 32, 41);"> 选项时发生。</font>
>
> **<font style="color:rgb(26, 32, 41);">更新</font>**<font style="color:rgb(26, 32, 41);">：如果源.py文件被修改，Python解释器会检测到这一点，并重新编译源文件生成新的.pyc文件。</font>
>

综上，这个东西并不能被我们的反汇编器IDA直接反汇编并编译为c伪代码供我们查看

由于.pyc是一个很常见的东西，所以现在网上各个平台的师傅们做的在线/离线反编译器非常之多，直接拽进去就可以看到源码，比如最经典的[pycdc](https://github.com/extremecoders-re/decompyle-builds)等（这个是GitHub上有师傅组装好的version

在上面的链接下下好pycdc.exe，随后把justpyc和pycdc置于同一目录下并在当前位置打开powershell

输入./pycdc 文件名.pyc并回车即可看到反编译的内容

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732164836048-0f7a1fcd-11fe-4a88-a56b-22195b713162.png)

（当然为了截图方便点我还是拿去别的网站上找了其他师傅写的在线轮子

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732114962839-fee806b2-a482-4e35-ad70-605abe1d7363.png)

运行python直接根据程序反推

1.程序会对我们输入的（input1）中的每个数加上序数再被128取模（再加128再取模相当于没操作）

2.对每两个相邻的元素进行异或操作^（异或操作：对8（B1000）和6（B0110）来说，比较每一位，相同为0，不同为1，结果即为B1110，即14）

^可以视作一种加密方式，但由于它满足交换律和结合律，因此也可以进行逆运算

我们现在已经知道code中现有的第a个元素是由原本的b^（b+1）运算得来的，那么，是否有一个key可以打破这个加密呢

对咯，就是code现有的最后一个元素a23，因为再没有对应的b24了，因此倒数第二个便是a22=b22^b23=b22^a23，即可解出b22=a22^a23，同理推得所有原始元素

程序如下![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732122148267-d45ec47f-6272-421b-8f77-1a117fe75769.png)

即可解出flag     GWHT{Just_Re_1s_Ha66y!}

---

<h1 id="Nw14g">3.maze</h1>
~~（这是这周作业第一个我能双击打开的文件TwT~~

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732165723735-6d91d2ab-e3c0-4ed4-983d-7fd099649a25.png)

ok，让我们通过谜题，那么我们先拖进ida看一眼

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732165778967-b74a8e8c-1da9-4181-b292-93e864593dac.png)

开 幕 雷 击

从对报错信息的直接翻译、百度和google而言，这个报错代表了我们的maze很大概率是个有壳程序

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732166145107-91c945ec-b667-43d6-960d-55789288d1f6.png)

强行反汇编的话第一行也会标红指出这个问题

查看壳的类型我们可以使用exeinfo工具

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732166304690-3cf4cf3f-b2ab-4ce9-8a0d-64e982b4e8b8.png)

这里exeinfo也是直接指出了它存在UPX壳

<h2 id="joEfn">1）轮子法</h2>
同上，upx壳用ups自己就能脱掉（也就是有官方轮子，[upx的github](https://github.com/upx/upx/releases/tag/v4.2.4)，[csdn上的脱壳教程](https://blog.csdn.net/qq_43633973/article/details/102573376)

但是为了应对以后更多样的壳，这里我们尝试手脱

<h2 id="Z2VzB">2）手动脱壳</h2>
与pyc不一样，壳子作为抽象意义上覆盖在原代码上为了混淆反编译器程序EP的起始点而产生的无用代码，因此，理论上只要能人工找到OEP，就可以手动脱壳，其中大名鼎鼎的就有[ESP定律](https://zhuanlan.zhihu.com/p/117294551)（在上篇笔记中亦有讲到，ESP作为栈顶指针对程序执行时的出入栈有非同寻常的意义），首先我们需要一个[x64dbg](https://github.com/x64dbg/x64dbg/releases)来查看

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732167590512-56e0ae35-03db-495c-a140-701a0b47c04d.png)

~~还是个32位程序~~打开x64dbg自带的x32bdg查看

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732167734199-14fcf1b7-ad40-4e44-914b-2dd3bed56d68.png)

点F9跳转到程序运行的起点，看到了pushad，这也是代码带壳的一个标志。为什么是pushad而不是常规的push，芝士<font style="color:rgb(77, 77, 77);">由于壳段代码需要保存当前寄存器的状态而生的，</font>我们选中pushad然后f8单步运行（步过）一次（如果程序直接运行（俗称跑飞）改f7单步进入call（步进））

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732168658706-8e2d879c-5426-4991-8c0f-d20399c8b3df.png)如图，运行了一次，再查看右侧寄存器窗口，仅有ESP寄存器后缀变红，那esp定律便是可行的

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732168887494-fae006ca-719f-48de-8dce-71487c2314e9.png)

选择在内存窗口中转到以查看具体位置及16进制数据

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732169046483-99d344f3-1894-42ce-bb77-d65bad24d2cb.png)

选中跳转过去对应起始字段往后拖拽任意长度（长度网上有说1有说2有说4有说8的，实际无所谓，因为计算机的检索机制仍然是起始点和长度，这里拖拽只是为了选中这个寄存器的第一个数据作为断点的起始点，长度取决于后面设置的字段类型，其实也无所谓，毕竟是断点）并设置断点

随后f9

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732179672633-60902692-66ad-4af6-ac1d-747e06c4dbd4.png)

如图所示，本条代码的上一行便是恢复计算机环境的popad

进入上方断点栏删掉断点，随后回到原位置f8逐步执行，直到跳转到OEP（

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732181573135-900909db-5110-43bb-bad7-07cb436c811a.png)

按照顺序点击（打开scylla并把脱完壳的程序dump下来）

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732181719654-330bdd98-4cbe-4251-868a-570ce5cb13b4.png)

发现有一个错误，dump下来的文件并不能正常打开，因此点击fix dump

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732181783461-3dae57ed-65ac-41a6-9187-bad2f202bfd7.png)

手动脱壳就结束了

接下来正常拖进32位ida进行查看

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732204448287-49ee70a0-b4ee-4441-b1c6-a85a282662e6.png)

x也x不了，f5更是做不到，左侧一串飘红（起初我以为是我传奇手动脱壳导致把UPX壳脱成了魔改upx壳，结果发现UPX自己的脱壳塞进去也是这个样子=.=）

因此，可以认定ida觉得这串代码堆栈并不平衡

但是我们可以打开这个程序啊，说明它实际上堆栈平衡

对咯，碰到花指令（junk code）了，如英文名所示，本质上是一串不影响程序逻辑的垃圾指令，用于影响反汇编器的正常运行，增加分析的难度

花指令大概分为两大类四小类，两大类即会被执行或不会被执行

> 1.不会被执行，但是操作码，此时junk code后表面本来的机器码会被误认为操作数，从而导致反汇编解析错误
>
> 2.不会被执行，是平衡栈堆的代码，ida解析时会由于该指令是堆栈操作而认为栈堆不平衡，使得f5失效
>
> 3.会被执行，是正常的汇编指令，可以改变堆栈操作但是不会改变原程序的堆栈寄存器，从而起到干扰静态分析的作用
>
> 4.会被执行，利用call增加复杂度，向栈堆中压入返回地址，可修改返回地址配合ret跳转至任意地方
>

显而易见的是这里的4类大量存在且大概率存在3类junk code

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732351104307-74607db2-05c9-4965-a333-0665c78c4f36.png)

比如这里，call near ptr后引用了一个明显不是地址的地址，显然这里大标红是ida都已经意识到了被花指令骗了（悲

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732353879046-736a3789-7b18-44f9-8572-b22ac15c01c9.png)

比如这条原地tp的就明显是junk code

遇到花指令，我们需要使用nop（就是右键那个橡皮擦）手动屏蔽掉部分指令

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732351317221-f74fefaa-aa71-46c1-9900-acaa964c7ad5.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732353944116-d459b2de-7b18-4e3f-ae55-0e983b8b7c1b.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732353963274-5c1da7c3-b8d9-47f1-9544-6a7f42edc6bf.png)

清静了（

nop掉之后的结果如图，直接x后f5会发现仍然不能编译

因为。。。nop多了，把有用的东西全给nop了

我们退出来回到这里，右键选择revert patch把刚刚的nop撤销掉

依旧是选中那一坨红的东西，按d把它转化成字节数据

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732354070925-f8a4a50c-9d16-423d-8a22-63db5bc2cbb4.png)

经过枚举可得转化出来擦掉0E8h即可使IDA ~~  大记忆恢复术  ~~ 成功把后续数据转化为指令

> 王爽的《汇编语言》P4：指令和数据都是应用上的概念，在内存和磁盘上，指令和数据没有任何区别。都是二进制信息。CPU在工作时把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。
>

这里就是这句话的一个非常生动的体现

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732354014647-fdd73077-1168-4e7f-bc80-d95fe16147bd.png)

现在，终于把被花指令用数据藏起来的指令还原出来了，我们用选中所有标红的部分，按一次p即可把上述部分声明为函数，去掉原本的飘红（注意从飘红的最下端开始选起，不是这（乐极生悲

对姗姗来迟的主函数照例按x再f5

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732354784872-ed184499-3a39-4cde-9f60-03a01dcf12c6.png)

终于不是五百多行跳来跳去的东西了（，出现这个也能证明去花成功了

ok，照例观察代码

首先可以确定的是我们的flag内容是一个十四位的东西，并且逐位读取

继续向下，对wasd分别做出了定义，有两个函数很引人注意，也就是定义他们的asc_408078和--dword_40807C。分别点开看看怎么个事情

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732355355455-c91169c9-b872-4137-86ff-a9247896b549.png)

往上瞟了一眼似乎看到了一些不得了的东西。。。结合题目名字而言，这大抵是个迷宫题。

因此这里应该就是初始位置和迷宫本体，回到一开始的伪代码看一眼

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732355648659-f3543b5b-6ea6-4ff8-9269-0fbccbc2d25e.png)

这里也就是最终的地方，也就是原程序的wasd大意便是移动

把迷宫誊到记事本上

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732355805787-ecbcb5a3-354a-414f-b06b-50b427a03788.png)

由上方告诉我们的加号与F的位置应当在(7,0)和(5,-4)对这些星号进行折叠以组成迷宫（切记计算机从0开始数数）

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732356199910-3c587e96-4fb2-40af-a995-39be4032fe14.png)

折叠如上

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732356312331-104b983b-9970-4d0a-995c-4efa57df39f4.png)

经过走迷宫可得flag为   flag{ssaaasaassdddw}

---

<h1 id="qzXIK">4.rand</h1>
从名字可以先入为主的觉得和随机数有关系（？

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732208129871-b101a200-ec62-43c9-8bd9-f6d2d567ba0d.png)

~~经过上一题的暂时努力未果决定先来做这个~~然后发现。。。欸，这是什么文件

这种情况就要打开010editor查看文件头来确定文件类型了

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732208222143-b09648a5-6aee-4a8c-8e70-d16b3ce4920f.png)

右侧直接指出了.ELF的文件类型，左侧7F起是.ELF的魔数，45 4C 46是16进制的ELF的二进制码从而锁定文件类型为.elf

有了后缀就可以拖进exeinfo分析进制，64位就拖进x64 IDA进行反汇编了

进去之后~~至少看上去~~目前结构很简单，先f5看看情况

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732208566279-ce532e53-18ba-40bf-875d-280070088641.png)

根据提示，打开下面的patch_me函数看看

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732254663485-32182685-d679-4da5-be32-722b2993f698.png)

可以看到输入的数需要是一个偶数才会触发else的get_flag

再打开get_flag看看

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732254764921-61dabd36-f6ce-41f2-b0d6-0fe6d0f81b71.png)

这里可以看到v6自己对自己的异或导致return的就是0，那么再看看中间的代码

rand是c语言很经典的一个根据随机数种子获取伪随机数的函数，因此作为一道有确定答案的题目，我们需要观察随机数种子srand的内容

srand取了一个根据时间生成的随机数种子，也是非常经典（

再观察一下下方，首先排除case2和case3，余下了case1、case4和case5，并且需要排序

因此我们需要继续观察三段代码的含义，根据case1中的信息，答案需要拼上f1和f2

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732261417712-2c1747da-858e-4d74-85bb-d86a1be76394.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732261071913-1f8e17b8-7e57-453d-91ea-4752d91ff68e.png)

双击f1可以看到这里是一个已经有值的"GXY{do_not_"字样，而此处f2是个地址，且双击跳转结果为乱码，因此先往下看

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732261435549-25fb857b-3b50-47ee-851f-f4acc8027791.png)

case4中先定义了一个很大的16进制数s（？），并把0赋值给了v5，并把f2和s作为两个字符串连接起来了，因此可以根据ASCII可以得知s中的每两位数应当拆成一个元素

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732261888819-d1f4673a-1399-4837-ba32-8e657d4ca2ab.png)

case5这里对f2的数组指针进行便宜，当j从0到7时，每过一个偶数便-1，奇数-2

根据以上分析，应当以case4用s定义f2 case5编辑f2 case1组合f1和f得到key的顺序进行排序

然后就是最后的写C语言求flag的时间了

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732275045806-f0b8f721-b41d-4ef7-b942-338f328b6805.png)



本题的flag为：GXY{do_not_hate_me}

---

<h1 id="ykGFW">5.windows</h1>
比较令人费解的标题（？

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732275209928-45c3e2a5-0ccb-476a-ad13-14196e03e1b1.png)

打开是刮刮乐の形式。。。然而直接用鼠标刮不开（悲

惯例现用exeinfo看一眼文件形式，然后直接用IDA正义刮开(乐

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732275774286-4fa702dc-5b58-4fb8-9a1a-b12bef0f52ab.png)

首先可以看到我们flag的内容长度应为8，先看看下面离成功语音最近的判断在表示什么

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732275848166-dd9498b0-2a35-4fdc-92b4-b613cec8f131.png)

上面是一个if后面跟了很多判断，逐一分析之

这边粉色的函数名并不清楚是什么，经过stfw知道了是可视化组件，因此暂时可以不管他

String[0]=v7[0]+34，乍一看是124，但是v7在上方被一个sub_4010F0函数操作过，因此还得先看一下sub_4010F0的具体内容

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732295589207-076c35d8-39d2-48e9-9b7d-4aad5f009623.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732295560842-1bde3b77-46cf-4574-b9f3-6a4d80272075.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732295464568-8146c806-190b-4d57-923a-84776e807efa.png)

经过阅读大致可知这是一个与排序有关的元素（全程都在和result比较，一旦比result大就会跳出循环，且最后会返回result作为结果），可见这是个把v7及之后的数从小到大的排列方式

原始序列为90 74 83 69 67 97 78 72 51 110 103

重新排列后应该为51 67 69 72 74 78  83 90 97 110 103

下面还有v4&v5使用的sub_401000函数也需要分析

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732292566762-e1a22736-5a20-4116-b5d4-9849c2091206.png)

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732292587529-1da9da4b-9a49-48f6-a983-d48c550b9754.png)

很长，但是看到/3和*4就立刻想到了例题1的base64编码，这里主要是为了留出空间方便后续操作，再看看具体写了什么

> 1. <font style="color:rgb(26, 32, 41);">计算所需缓冲区的大小，v4=4 * v2 + 1，这里 v2是输入长度 a2除以3并向上取整，然后malloc动态内存分配一个大小为 v4的缓冲区v5。</font>
> 2. <font style="color:rgb(26, 32, 41);">使用 memset将分配的缓冲区清零。</font>
> 3. <font style="color:rgb(26, 32, 41);">如果输入长度 a2大于0，则进入一个循环，这个循环将输入数据分组为每3个字节一组，并执行以下操作：</font>
>
> <font style="color:rgb(26, 32, 41);">将3个字节（或更少，如果最后不足3个字节）合并为一个24位的值v9。</font>
>
> <font style="color:rgb(26, 32, 41);">将 v9的每个6位部分转换为64字符集中的字符。通过左移和掩码操作来完成，然后将结果用作索引来从 byte_407830表中选择一个字符</font>
>
> <font style="color:rgb(26, 32, 41);">每次循环将转换后的字符存储到缓冲区 v5中，并更新指针 v8。</font>
>
> 4. <font style="color:rgb(26, 32, 41);">循环直到所有输入数据都被处理。</font>
> 5. <font style="color:rgb(26, 32, 41);">在缓冲区的末尾添加一个空字符（*v8=0），以此保证结果字符串正确终止。</font>
> 6. <font style="color:rgb(26, 32, 41);">返回编码后的字符串。</font>
>

由上段分析得出v8会被一个byte_407830操作，点开byte_407830看看是什么

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732294670286-f83dfb25-4f37-440d-98aa-bb46e4b06a5c.png)

恍然大悟（

因此可以见得这段代码的意义就在于给输入进行base64编码，即这是个base64编码函数

返回主函数决定flag的代码串

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732296977837-069e8f17-de45-4ce4-aa9b-e40bc0116a03.png)

v7[0]为最小的数51，+34为85，即U

v10对应的数字为74，为J

v8对应的数字为69，第三个字符的计算方式即为(69*3+141)/4，为87，对表可得W

v13为90，第四个字符即为80，对表可得P

v4为ak1w，需要通过base64反编码，结果为jMp

v5同理，结果为WP1

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732297512540-63b41f4b-8c66-46e7-a093-d8d218d7fbd8.png)

由此处可知，v5为str的2、3、4位，v4为5、6、7位，再结合已知的0、1、2、3位

得出八位flag UJWP1jMp

~~什么泰坦尼克号~~

---

<h1 id="YHJ1j">6.XOR</h1>
标题是异或（？~~有种第四题弄得我痛不欲生的junk code要卷土重来的美    ~~其实并不是，倒是类似于第二题的异或加密反运算

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732297910355-dcdb4ffe-ec61-44c0-9ada-05e11d2a6e91.png)

又是一个没有后缀的文件，照惯例，拖进010editor溜溜

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732297955378-b0fd4349-407c-4643-b246-2385ae38ed35.png)

经过对文件头的查询，得出这是Mach-O文件的文件头，是个ios的执行格式

~~  emmm，但是mac没带过来  ~~

经暴力拖拽，ida能打开这个文件

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732339182539-efc66a4d-0b74-44c1-b6f2-403a4ddad625.png)

找到了input your flag的提示信息，f5反编译成c语言伪代码



![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732348348977-ae418b40-27cb-4c22-a1e1-596e6902d6fa.png)

得到代码串，如图所示，先是清空内存，并且可以看出我们的flag长度为33个字（b不为33个字会跳至LABEL7，即下面的printf failedの失败结算）

随后b中的元素每个都会和前一个进行异或运算并且存储到原本的位置

那么这次的key便是整个b数组的第一个元素，因为b[]数组中再没有b[-1]来给b[0]进行异或运算，因此我们可以利用[3]中maze的思路运用global和b中的第一个元素来反向还原整个原本的b数组

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732349353665-cfc08026-fbd9-4e90-9d95-545c264f3bfd.png)

可以看得出来经过变化后的_global中有~~  正好有16个字  ~~  并不，这是一个长得很像目标的数组（所以记得多点开看看）

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732349931424-17b7a477-7c04-4d8a-b217-6dd16a80b7f8.png)

这里才是我们的对应答案，也就是我们异或操作完之后的值

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732349973995-59536b31-83ef-4c83-a98a-acbecf154570.png)

有个比较快捷的方法就是可以选中数组后直接shift+E，就可以打开ida内置的数据转换器，我们把它摘下来，即：

{102, 10, 107, 12, 119, 38, 79, 46, 64, 17, 120, 13, 90, 59, 85, 17, 112, 25, 70, 31, 118, 34, 77, 35, 68, 14, 103, 6, 104, 15, 71, 50, 79}，最后一个0请切记舍弃，因为它在上方并没有单引号的字符标明，而是计算机终止读取的代表。

然后就可以利用2.justpyc中类似的方式对其进行解码

请注意，这里的大括号进了python要改成中括号，不然会因为被识别为set类而非list类导致不支持排序

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1732350878960-6a30694d-8f99-4af1-9d71-5a31040648d1.png)

本题的flag即为    flag{QianQiuWanDai_YiTongJiangHu}

还好没有花指令感谢出题人手下留情（这道题因为有一个集中跳转的部分使得我一度认为中间存在花指令QwQ

这题大致上没什么好讲的（要讲的基本已经在第二题讲过了，思路是很类似的















